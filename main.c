#include <pspkernel.h>
#include <pspdisplay.h>
#include <psptypes.h>
#include <psprtc.h>


PSP_MODULE_INFO("dvd logo", PSP_MODULE_USER, 0, 0);
PSP_MAIN_THREAD_ATTR(THREAD_ATTR_USER);


#define SCREEN_W 480
#define SCREEN_H 272

#define LOGO_W 80
#define LOGO_H 34
#define PIXEL_PER_BYTE 8


// monochrome 1 bit per pixel logo
u8 logo[] = { 
  0x00,0xFF,0xFF,0xFF,0xF8,0x00,0x3F,0xFF,0xFE,0x00,
  0x00,0xFF,0xFF,0xFF,0xF8,0x00,0x7F,0xFF,0xFF,0x80,
  0x00,0xFF,0xFF,0xFF,0xF8,0x00,0xFF,0xFF,0xFF,0xE0,
  0x01,0xFF,0xFF,0xFF,0xFC,0x01,0xFF,0xFF,0xFF,0xF0,
  0x00,0x00,0x0F,0xFD,0xFC,0x03,0xFC,0x00,0x1F,0xF8,
  0x00,0x00,0x03,0xFE,0xFC,0x03,0xF8,0x00,0x07,0xFC,
  0x01,0xFC,0x01,0xFE,0xFE,0x07,0xF3,0xF8,0x03,0xFC,
  0x01,0xFC,0x01,0xFE,0xFE,0x0F,0xF3,0xF8,0x03,0xFC,
  0x03,0xFC,0x00,0xFE,0xFE,0x1F,0xE7,0xF8,0x03,0xFC,
  0x03,0xFC,0x01,0xFE,0x7F,0x3F,0xC7,0xF0,0x03,0xFC,
  0x03,0xF8,0x01,0xFE,0x7F,0x3F,0x87,0xF0,0x03,0xFC,
  0x03,0xF8,0x03,0xFC,0x7F,0x7F,0x07,0xF0,0x07,0xF8,
  0x03,0xF8,0x03,0xFC,0x3F,0xFE,0x0F,0xF0,0x07,0xF8,
  0x07,0xF8,0x0F,0xF8,0x3F,0xFC,0x0F,0xF0,0x1F,0xF0,
  0x07,0xF0,0x3F,0xF0,0x3F,0xFC,0x0F,0xE0,0x7F,0xE0,
  0x07,0xFF,0xFF,0xE0,0x1F,0xF8,0x0F,0xFF,0xFF,0x80,
  0x07,0xFF,0xFF,0x80,0x1F,0xF0,0x1F,0xFF,0xFF,0x00,
  0x0F,0xFF,0xFE,0x00,0x1F,0xE0,0x1F,0xFF,0xFC,0x00,
  0x0F,0xFF,0xF0,0x00,0x0F,0xC0,0x1F,0xFF,0xE0,0x00,
  0x00,0x00,0x00,0x00,0x0F,0x80,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,
  0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
  0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,
  0x0F,0xFF,0xFF,0xFF,0xC1,0xFF,0xFF,0xFF,0xFF,0x00,
  0x3F,0xFF,0xFF,0xF8,0x00,0x0F,0xFF,0xFF,0xFF,0xC0,
  0x3F,0xFF,0xFF,0xF8,0x00,0x07,0xFF,0xFF,0xFF,0xC0,
  0x1F,0xFF,0xFF,0xFE,0x00,0x3F,0xFF,0xFF,0xFF,0x00,
  0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,
  0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,
  0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00
};

// main thread id
int thid;
// main running flag
int running;


// convert 0-359 degree value to u32 ABGR color
u32 color_wheel(int degrees);


// main thread
int main_thread(SceSize args, void *argp){
	u64 tick;
	unsigned int* vram32;
	int bufferwidth, pixelformat;
	
	// wait for psp boot
	sceKernelDelayThread(10 * 1000 * 1000);
	// get psp ticks for pseudo randomness
	sceRtcGetCurrentTick(&tick);
	
	// set logo start position from ticks
	s16 logo_x = tick % (SCREEN_W - LOGO_W);
	s16 logo_y = tick % (SCREEN_H - LOGO_H);
	// set logo movement from start position
	s16 logo_vx = (logo_x & 1) ? -1 : 1;
	s16 logo_vy = (logo_y & 1) ? -1 : 1;
	// logo color
	u32 logo_color = color_wheel((int)((tick / 1000) % 360));
	
	// main menu
	while (running){
		// check x collision
		if ((logo_x + logo_vx) >= (SCREEN_W - LOGO_W) || (logo_x + logo_vx) <= 0){
			//change direction
			logo_vx = -logo_vx;
			// update tick value when changing direction
			sceRtcGetCurrentTick(&tick);
			// change color based on tick value
			logo_color = color_wheel((int)((tick / 1000) % 360));
		}
		// check y collision
		if ((logo_y + logo_vy) >= (SCREEN_H - LOGO_H) || (logo_y + logo_vy) <= 0){
			//change direction
			logo_vy = -logo_vy;
			// update tick value when changing direction
			sceRtcGetCurrentTick(&tick);
			// change color based on tick value
			logo_color = color_wheel((int)((tick / 1000) % 360));
		}

		// move logo
		logo_x += logo_vx;
		logo_y += logo_vy;
		
		
		// get vram
		int ret = sceDisplayGetFrameBuf((void*)&vram32, &bufferwidth, &pixelformat, PSP_DISPLAY_SETBUF_IMMEDIATE); 
		// works with both PSP_DISPLAY_SETBUF_NEXTFRAME and PSP_DISPLAY_SETBUF_IMMEDIATE
		
		// check if return value from sceDisplayGetFrameBuf is valid
		// check if vram32 is not NULL
		// check if bufferwidth is not 0
		if (ret == 0 && vram32 != NULL && bufferwidth != 0){
			// draw logo
			for (int i = 0; i < LOGO_H; i++){
				for (int j = 0; j < LOGO_W; j++){
					// check if the pixel bit of the logo at position 'j' is 1
					if (logo[(i * (LOGO_W / PIXEL_PER_BYTE)) + j / PIXEL_PER_BYTE] & (1 << (PIXEL_PER_BYTE - 1 - (j % PIXEL_PER_BYTE)))){
						// write logo to vram
						vram32[(logo_y + i) * bufferwidth + (logo_x + j)] = logo_color;
					}
				}
			}
		}
		// not checking return value and/or vram32 pointer will result in a crash when putting the PSP to sleep
		
		
		// wait for vblank and allow for callbacks
		if (sceDisplayWaitVblankStartCB() < 0)
			break; // end of VSH ?
	}

	return sceKernelExitDeleteThread(0);
}



int module_start(SceSize args, void *argp){
	running = 0;
	// create and start main thread
	thid = sceKernelCreateThread("dvd_logo_thread", main_thread, 0x10, 4*1024, PSP_THREAD_ATTR_USER, NULL);
	if (thid >= 0){
		running = 1;
		sceKernelStartThread(thid, args, argp);
	}
	
	return 0;
}

int module_stop(SceSize args, void *argp){
	// clean exit main thread
	if (running){
		running = 0;
		SceUInt time = 200*1000;
		int ret = sceKernelWaitThreadEnd(thid, &time);
		if (ret < 0)
			sceKernelTerminateDeleteThread(thid);
	}
	
	return 0;
}



// convert 0-359 degree value to u32 ABGR color
u32 color_wheel(int degrees){
	u8 red = 0, green = 0, blue = 0;
	degrees = degrees % 360;
	
	if (degrees < 120){
		red = ((120 - degrees) * 255) / 120;
		green = (degrees * 255) / 120;
		blue = 0;
	}else if (degrees < 240){
		degrees -= 120;
		red = 0;
		green = ((120 - degrees) * 255) / 120;
		blue = (degrees * 255) / 120;
	}else{
		degrees -= 240;
		red = (degrees * 255) / 120;
		green = 0;
		blue = ((120 - degrees) * 255) / 120;
    }
	
	return (0xFF000000 | blue << 16 | green << 8 | red);
}